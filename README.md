# 20233154 이서준 오픈소스 과제
---


리눅스 명령어 중에서 top, ps, jobs, kill 명령어에 대해서 조사


1. top
2. ps
3. jobs
4. kill

---
# top

* 시스템의 상태를 전반적으로 가장 빠르게 파악 가능(CPU, Memory, Process)
* 옵션 없이 입력하면 interval 간격(기본 3초)으로 화면을 갱신하며 정보를 보여줌


**top 명령어 실행 사진**

![top 사진](https://github.com/dltjwns1213/open-source-/assets/133830062/6dd80549-1383-48c6-9a4d-cb8a2866b467)


## VIRT, RES, SHR

* VIRT
  - 프로세스가 사용하고 있는 virtual memory의 전체 용량
  - 프로세스에 할당된 가상 메모리 전체
  - SWAP + RES
* RES
  - 현재 프로세스가 사용하고 있는 물리 메모리의 양
  - 실제로 메모리에 올려서 사용하고 있는 물리 메모리
  - 실제로 메모리를 쓰고 있는 RES가 핵심
* SHR
  - 다른 프로세스와 공유하고 있는 shared memory의 양
  - 예시로 라이브러리를 들 수 있음. 대부분의 리눅스 프로세스는 glibc라는 라이브러리를 참고하기에 이런 라이브러리를 공유 메모리에 올려서 사용
 
 
**top 실행 후 명령어**


|옵션|설명|
|---|:---:|
|shift + p|CPU 사용률 내림차순|
|shit + m|메모리 사용률 내림차순|
|shift + t|프로세스가 돌아가고 있는 시간 순|
|k|kill. k 입력 후 PID 번호 작성. signal은 9|
|f|sort field 선택 화면 -> q 누르면 RES순으로 정렬|
|a|메모리 사용량에 따라 정렬|
|b|Batch 모드로 작동|
|1|CPU Core별로 사용량 보여줌|



---
# ps

* ps는 process status의 줄이말이며, 현재 실행중인 프로세스 목록과 상태를 출력하여 보여주는 기능을 한다.
* 윈도우로 따지면 작업관리자와 비슷하다.


**ps 명령어 실행 사진**


![ps 캡처](https://github.com/dltjwns1213/open-source-/assets/133830062/1bd8ec58-f20f-4e4f-af70-a347745685fc)

## PID,TTY,TIME

* PID
  - 프로세스마다 주어지는 번호
* TTY
  - 명령어가 실행되는 터미널의 번호(할당된 것이 없는 경우 물음표 출력)
* TIME
  - CPU가 사용한 시간





## 자주 사용되는 ps 명령어 옵션 사용 예시
```* ps -ef : 모든 프로세스를 풀 포맷으로 출력
* ps -ef|grep '프로세스명' : '프로세스명'의 프로세스 구동 확인
*  ps aux : 실행중인 모든 프로세스 확인
*  ps auxf : 실행 중인 모든 프로세르를 트리구조로 출력
*  ps auxfww : 실행 중인 프로세스를 트리구조 + 모든 실행 중인 옵션 확인가능
```




**ps 명령어 주요 옵션**

|옵션|설명|
|---|:---:|
|-A|모든 프로세스를 출력|
|-a|세션 리더를 제외하고 데몬 프로세스처럼 터미널에 종속되지 않은 모든 프로세스를 출력|
|-e|커널 프로세스를 제외한 모든 프로세스를 출력|
|-f|full 포멧 출력|
|-l|긴 포맷으로 출력|
|-o 값|출력 포맷을 지정하는 옵션으로 값으로는 pid, tty, tiem, cmd 등을 지정하여 출력|
|-M|64비트 프로세스 출력|
|-p|특정 PID를 지정할때 사용|
|-r|현재 실행중인 프로세서를 출력|
|u|프로세스의 소유자를 기준으로 출력|



---
# jobs

* jobs 명령어는 작업의 상태를 표시하는 명령어다,
* 현재 쉘 세션에서 실행시킨 백그라운드 작업의 목록이 출력된다.

**jobs 명령어 실행 사진**


![jobs 명령어](https://github.com/dltjwns1213/open-source-/assets/133830062/7c50753e-c925-4701-a094-1896ac35f7df)


**jobs 명령어로 출력되는 백그라운드 작업의 상태값**
|상태|설명|
|---|:---:|
|Running|작업이 계속 진행중임|
|Done|작업이 완료되어 0을 반환|
|Done(code)|작업이 종료되었으며 0이 아닌 코드를 반환|
|stopped|작업이 일시 중단|
|Stopped(SIGTSTP)|SIGTSTP 시그널이 작업을 일시 중단|
|Stopped(SIGSTOP)|SIGSTOP 시그널이 작업을 일시 중단|
|Stopped(SIGTTIN)|SIGTTIN 시그널이 작업을 일시 중단|
|Stopped(SIGTTOU)|SIGTTOU 시그널이 작업을 일시 중단|


**jobs 명령어 옵션**
|옵션|설명|
|---|:---:|
|-l|프로세스 그룹 ID 를 state 필드 앞에 출력|
|-n|프로세스 그룹 중에 대표 프로세스 ID를 출력|
|-p|각 프로세스 ID에 대해 한 행씩 출력|
|command|지정한 명령어를 실행|



---

# kill
* 프로세스에 일정한 signal을 보내는 명령어 
* 일반적으로 프로세스 종료 명령어로 많이 알려져 있는데 -s 옵션으로 시그널을 지정하지 않으면 기본 시그널 값이 정상종료(SIGTERM,15)이기 때문이다.

## kill 명령어
**사용 형식**
```pid: 프로세스 ID(ps 또는 jobs 명령어를 통해 프로세스 ID를 확인할 수 있습니다.)

1. 시그널을 지정하지 않을 경우 기본 값인 정상 종료(15, SIGTERM) 시그널을 보냅니다.
  1. kill [pid]

2. 시그널 지정
  1. kill -s [signal id] [pid]
  2. kill -s [signal text] [pid]
  3. kill -[signal id] [pid]
  4. kill -[signal text] [pid]
 ```
 
 ## 시그널
* 시그널이란 인터럽트의 일종으로 어떤 이벤트의 발생을 프로세스에게 알려주는 것입니다.
* 특정 이벤트가 발생했을 때 프로세스에게 전달하는 신호(메시지)
* 리눅스에서 프로세스끼리 통신할 때 사용합니다.
* 시그널 이벤트로는 HW 예외(나누기 0), SW 상태, 사용자 입력, 시스템 콜(kill) 등이 있습니다.


**리눅스 사용자 입력에 의한 시그널(인터럽트 시그널)**
|단축키|설명|
|---|:---:|
|ctrl+c|실행중인 프로세스에 SIGINT 신호를 보냅니다.(프로세스 종료)|
|ctrl+z|실행중인 프로세스에 SIGTSTP 신호를 보냅니다.(프로세스 정지)|
|ctrl+&#92;|실행중인 프로세스에 SIGQUIT 신호를 보냅니다.(프로세스 종료 + 코어 덤프)|


## 시그널 종류
  
  ![kill](https://github.com/dltjwns1213/open-source-/assets/133830062/907f566d-bf33-4822-be5b-edbb2027306b)
  
* kill -l 명령어를 이용해 사용할 수 있는 시그널을 확인할 수 있습니다.

